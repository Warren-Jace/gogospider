# GogoSpider ä¸‰å¤§ä¼˜åŒ–éœ€æ±‚å®æ–½æ–¹æ¡ˆ

**ç‰ˆæœ¬**: v4.8  
**æ—¥æœŸ**: 2025-11-06  
**éœ€æ±‚æ¥æº**: ç”¨æˆ·åé¦ˆ

---

## ğŸ“‹ éœ€æ±‚æ¦‚è§ˆ

### éœ€æ±‚1: JSæ–‡ä»¶ç‰¹æ®Šå¤„ç† ğŸ”¥
- âœ… é»‘åå•æ£€æŸ¥ï¼ˆå¿…éœ€ï¼‰
- âœ… JSæ–‡ä»¶ä¸å—scopeé™åˆ¶ï¼ˆå¯è·¨åŸŸçˆ¬å–ï¼‰
- âœ… è·¯å¾„è‡ªåŠ¨æ‹¼æ¥

### éœ€æ±‚2: ä¸¤å±‚è¿‡æ»¤æœºåˆ¶ ğŸ”¥
- **Layer 1**: é™æ€èµ„æºè¿‡æ»¤ï¼ˆé™¤JSå¤–ï¼‰
  - åªè®°å½•ä¸è¯·æ±‚
  - æ³¨æ„ï¼š`?file=text.css` ä¸ç®—é™æ€èµ„æº
- **Layer 2**: ç›¸ä¼¼URLå»é‡
  - å‚æ•°ä¸åŒï¼š`?t=a&tt=b` vs `?tt=s&t=l`
  - è·¯å¾„å˜é‡ï¼š`/test-1/` vs `/test-2/`
  - ä½¿ç”¨hashç®—æ³•

### éœ€æ±‚3: DOM Embeddingç®—æ³• ğŸ”¥
- å°†DOMè½¬ä¸ºå‘é‡ `[1,2,3,4,5,6...]`
- hash Ã— èŠ‚ç‚¹æ·±åº¦ Ã— æƒé‡
- ä½™å¼¦ç›¸ä¼¼åº¦è®¡ç®—

---

## ğŸ¯ å®æ–½æ–¹æ¡ˆ

---

## éœ€æ±‚1: JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†

### 1.1 è®¾è®¡æ€è·¯

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      URLè¿‡æ»¤æµç¨‹ï¼ˆJSç‰¹æ®Šå¤„ç†ï¼‰      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         æ–°URLå‘ç°
             â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  é»‘åå•æ£€æŸ¥     â”‚ â† æ‰€æœ‰URLå¿…é¡»é€šè¿‡
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  æ–‡ä»¶ç±»å‹åˆ¤æ–­   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†™          â†˜
    [JSæ–‡ä»¶]      [å…¶ä»–]
         â†“           â†“
    è·³è¿‡Scope   Scopeæ£€æŸ¥
    æ£€æŸ¥            â†“
         â†“       [é€šè¿‡/æ‹’ç»]
    è·¯å¾„æ‹¼æ¥
         â†“
    å…è®¸çˆ¬å–
```

### 1.2 ä»£ç å®ç°

#### æ–‡ä»¶: `core/js_scope_handler.go` (æ–°å»º)

```go
package core

import (
	"fmt"
	"net/url"
	"path"
	"strings"
)

// JSSpecialHandler JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†å™¨
type JSSpecialHandler struct {
	// é»‘åå•åŸŸå
	blacklistDomains map[string]bool
	
	// ç›®æ ‡åŸºç¡€URLï¼ˆç”¨äºæ‹¼æ¥ï¼‰
	baseURL *url.URL
	
	// ç»Ÿè®¡
	stats JSHandlerStats
}

type JSHandlerStats struct {
	TotalJSFiles    int // æ€»JSæ–‡ä»¶æ•°
	CrossDomainJS   int // è·¨åŸŸJSæ•°
	LocalJS         int // æœ¬åŸŸJSæ•°
	PathJoined      int // è·¯å¾„æ‹¼æ¥æ•°
	BlacklistBlock  int // é»‘åå•æ‹¦æˆªæ•°
}

// NewJSSpecialHandler åˆ›å»ºJSç‰¹æ®Šå¤„ç†å™¨
func NewJSSpecialHandler(targetURL string, blacklist []string) (*JSSpecialHandler, error) {
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil, fmt.Errorf("è§£æç›®æ ‡URLå¤±è´¥: %v", err)
	}
	
	handler := &JSSpecialHandler{
		blacklistDomains: make(map[string]bool),
		baseURL:          parsedURL,
		stats:            JSHandlerStats{},
	}
	
	// åˆå§‹åŒ–é»‘åå•
	for _, domain := range blacklist {
		handler.blacklistDomains[strings.ToLower(domain)] = true
	}
	
	return handler, nil
}

// ShouldProcessJS åˆ¤æ–­JSæ–‡ä»¶æ˜¯å¦åº”è¯¥å¤„ç†
// è¿”å›: (æ˜¯å¦å¤„ç†, å¤„ç†åçš„URL, åŸå› )
func (h *JSSpecialHandler) ShouldProcessJS(rawURL string) (bool, string, string) {
	// 1. åˆ¤æ–­æ˜¯å¦ä¸ºJSæ–‡ä»¶
	if !h.isJSFile(rawURL) {
		return false, "", "ä¸æ˜¯JSæ–‡ä»¶"
	}
	
	h.stats.TotalJSFiles++
	
	// 2. è§£æURL
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		return false, "", fmt.Sprintf("URLè§£æå¤±è´¥: %v", err)
	}
	
	// 3. é»‘åå•æ£€æŸ¥ï¼ˆå¿…éœ€ï¼‰
	if h.isBlacklisted(parsedURL.Host) {
		h.stats.BlacklistBlock++
		return false, "", fmt.Sprintf("é»‘åå•åŸŸå: %s", parsedURL.Host)
	}
	
	// 4. è·¯å¾„æ‹¼æ¥å¤„ç†
	finalURL := rawURL
	
	// å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„æˆ–åè®®ç›¸å¯¹è·¯å¾„ï¼Œè¿›è¡Œæ‹¼æ¥
	if strings.HasPrefix(rawURL, "//") {
		// åè®®ç›¸å¯¹è·¯å¾„: //cdn.example.com/app.js
		finalURL = h.baseURL.Scheme + ":" + rawURL
		h.stats.PathJoined++
		
	} else if strings.HasPrefix(rawURL, "/") {
		// ç»å¯¹è·¯å¾„: /static/app.js
		finalURL = fmt.Sprintf("%s://%s%s", 
			h.baseURL.Scheme, 
			h.baseURL.Host, 
			rawURL)
		h.stats.PathJoined++
		h.stats.LocalJS++
		
	} else if !strings.HasPrefix(rawURL, "http://") && 
	          !strings.HasPrefix(rawURL, "https://") {
		// ç›¸å¯¹è·¯å¾„: ../js/app.js æˆ– js/app.js
		basePath := path.Dir(h.baseURL.Path)
		joinedPath := path.Join(basePath, rawURL)
		finalURL = fmt.Sprintf("%s://%s%s",
			h.baseURL.Scheme,
			h.baseURL.Host,
			joinedPath)
		h.stats.PathJoined++
		h.stats.LocalJS++
		
	} else {
		// å®Œæ•´URL: http://cdn.example.com/app.js
		if parsedURL.Host != h.baseURL.Host {
			h.stats.CrossDomainJS++
		} else {
			h.stats.LocalJS++
		}
	}
	
	// âœ… JSæ–‡ä»¶ä¸å—Scopeé™åˆ¶ï¼Œç›´æ¥å…è®¸
	return true, finalURL, "JSæ–‡ä»¶ï¼Œå…è®¸è·¨åŸŸçˆ¬å–"
}

// isJSFile åˆ¤æ–­æ˜¯å¦ä¸ºJSæ–‡ä»¶
func (h *JSSpecialHandler) isJSFile(rawURL string) bool {
	lowerURL := strings.ToLower(rawURL)
	
	// æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
	jsExtensions := []string{".js", ".mjs", ".jsx"}
	for _, ext := range jsExtensions {
		if strings.HasSuffix(lowerURL, ext) {
			return true
		}
		// å¤„ç†å¸¦å‚æ•°çš„æƒ…å†µ: app.js?v=123
		if strings.Contains(lowerURL, ext+"?") {
			return true
		}
	}
	
	// æ£€æŸ¥MIMEç±»å‹æç¤º
	if strings.Contains(lowerURL, "javascript") {
		return true
	}
	
	return false
}

// isBlacklisted æ£€æŸ¥åŸŸåæ˜¯å¦åœ¨é»‘åå•ä¸­
func (h *JSSpecialHandler) isBlacklisted(domain string) bool {
	domain = strings.ToLower(domain)
	
	// ç²¾ç¡®åŒ¹é…
	if h.blacklistDomains[domain] {
		return true
	}
	
	// é€šé…ç¬¦åŒ¹é…: *.example.com
	parts := strings.Split(domain, ".")
	for i := 0; i < len(parts); i++ {
		wildcard := "*." + strings.Join(parts[i:], ".")
		if h.blacklistDomains[wildcard] {
			return true
		}
	}
	
	return false
}

// GetStatistics è·å–ç»Ÿè®¡ä¿¡æ¯
func (h *JSSpecialHandler) GetStatistics() JSHandlerStats {
	return h.stats
}

// PrintReport æ‰“å°ç»Ÿè®¡æŠ¥å‘Š
func (h *JSSpecialHandler) PrintReport() {
	fmt.Println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘      JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†ç»Ÿè®¡æŠ¥å‘Š          â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Printf("  æ€»JSæ–‡ä»¶æ•°:      %d\n", h.stats.TotalJSFiles)
	fmt.Printf("  æœ¬åŸŸJS:          %d\n", h.stats.LocalJS)
	fmt.Printf("  è·¨åŸŸJS:          %d\n", h.stats.CrossDomainJS)
	fmt.Printf("  è·¯å¾„æ‹¼æ¥:        %d\n", h.stats.PathJoined)
	fmt.Printf("  é»‘åå•æ‹¦æˆª:      %d\n", h.stats.BlacklistBlock)
	fmt.Println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
}
```

#### é›†æˆåˆ° spider.go

```go
// spider.go

type Spider struct {
	...
	jsHandler  *JSSpecialHandler // ğŸ†• JSç‰¹æ®Šå¤„ç†å™¨
	...
}

func NewSpider(cfg *config.Config) *Spider {
	...
	
	// åˆå§‹åŒ–JSå¤„ç†å™¨
	jsHandler, err := NewJSSpecialHandler(
		cfg.TargetURL,
		cfg.BlacklistSettings.Domains, // é»‘åå•
	)
	if err != nil {
		logger.Warn("JSå¤„ç†å™¨åˆå§‹åŒ–å¤±è´¥", "error", err)
	}
	
	return &Spider{
		...
		jsHandler: jsHandler,
		...
	}
}

// åœ¨çˆ¬å–å¾ªç¯ä¸­ä½¿ç”¨
func (s *Spider) processBFSResults(...) {
	for link := range allLinks {
		
		// ğŸ†• Step 0: JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†
		if s.jsHandler != nil {
			shouldProcess, processedURL, reason := s.jsHandler.ShouldProcessJS(link)
			if shouldProcess {
				// JSæ–‡ä»¶ç›´æ¥å…è®¸ï¼Œè·³è¿‡Scopeæ£€æŸ¥
				tasksToSubmit = append(tasksToSubmit, processedURL)
				s.logger.Debug("JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†",
					"original", link,
					"processed", processedURL,
					"reason", reason)
				continue
			}
			// å¦‚æœä¸æ˜¯JSæ–‡ä»¶ï¼Œç»§ç»­æ­£å¸¸æµç¨‹
		}
		
		// Step 1: ç²¾ç¡®å»é‡
		if s.duplicateHandler.IsDuplicateURL(link) {
			continue
		}
		
		// Step 2: Scopeæ£€æŸ¥ï¼ˆJSæ–‡ä»¶å·²è·³è¿‡ï¼‰
		if s.scopeController != nil && !s.scopeController.IsInScope(link) {
			continue
		}
		
		...
	}
}
```

---

## éœ€æ±‚2.1: é™æ€èµ„æºè¿‡æ»¤ï¼ˆé™¤JSå¤–ï¼‰

### 2.1 è®¾è®¡æ€è·¯

**æ ¸å¿ƒåŸåˆ™**:
1. âœ… å›¾ç‰‡ã€CSSã€å­—ä½“ç­‰ â†’ åªè®°å½•ä¸è¯·æ±‚
2. âœ… JSæ–‡ä»¶ â†’ æ­£å¸¸è¯·æ±‚å’Œåˆ†æ
3. âš ï¸ å‚æ•°åŒ–URLå¦‚ `?file=test.css` â†’ ä¸ç®—é™æ€èµ„æºï¼Œéœ€è¦è¯·æ±‚

### 2.2 ä»£ç å®ç°

#### æ–‡ä»¶: `core/static_resource_filter.go` (æ–°å»º)

```go
package core

import (
	"fmt"
	"net/url"
	"strings"
	"sync"
)

// StaticResourceFilter é™æ€èµ„æºè¿‡æ»¤å™¨
type StaticResourceFilter struct {
	mutex sync.RWMutex
	
	// é…ç½®
	excludeExtensions map[string]bool // è¦è¿‡æ»¤çš„æ‰©å±•å
	jsExtensions      map[string]bool // JSæ‰©å±•åï¼ˆç‰¹æ®Šå¤„ç†ï¼‰
	
	// è®°å½•çš„é™æ€èµ„æº
	recordedResources map[string]ResourceInfo
	
	// ç»Ÿè®¡
	stats StaticFilterStats
}

type ResourceInfo struct {
	URL          string
	ResourceType string // image/css/font/documentç­‰
	RecordTime   string
}

type StaticFilterStats struct {
	TotalChecked    int
	ImagesFiltered  int
	CSSFiltered     int
	FontsFiltered   int
	DocsFiltered    int
	JSAllowed       int  // JSæ–‡ä»¶æ”¾è¡Œæ•°
	ParamURLAllowed int  // å‚æ•°åŒ–URLæ”¾è¡Œæ•°
}

// NewStaticResourceFilter åˆ›å»ºé™æ€èµ„æºè¿‡æ»¤å™¨
func NewStaticResourceFilter(excludeExts []string) *StaticResourceFilter {
	filter := &StaticResourceFilter{
		excludeExtensions: make(map[string]bool),
		jsExtensions:      make(map[string]bool),
		recordedResources: make(map[string]ResourceInfo),
		stats:             StaticFilterStats{},
	}
	
	// JSæ‰©å±•åï¼ˆä¸è¿‡æ»¤ï¼‰
	jsExts := []string{"js", "mjs", "jsx"}
	for _, ext := range jsExts {
		filter.jsExtensions[strings.ToLower(ext)] = true
	}
	
	// å…¶ä»–é™æ€èµ„æºæ‰©å±•åï¼ˆè¿‡æ»¤ï¼‰
	for _, ext := range excludeExts {
		extLower := strings.ToLower(strings.TrimPrefix(ext, "."))
		// è·³è¿‡JSæ‰©å±•å
		if !filter.jsExtensions[extLower] {
			filter.excludeExtensions[extLower] = true
		}
	}
	
	return filter
}

// ShouldFilter åˆ¤æ–­URLæ˜¯å¦åº”è¯¥è¿‡æ»¤
// è¿”å›: (æ˜¯å¦è¿‡æ»¤, èµ„æºç±»å‹, åŸå› )
func (f *StaticResourceFilter) ShouldFilter(rawURL string) (bool, string, string) {
	f.mutex.Lock()
	defer f.mutex.Unlock()
	
	f.stats.TotalChecked++
	
	// 1. è§£æURL
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		return false, "", "URLè§£æå¤±è´¥"
	}
	
	// 2. æå–æ–‡ä»¶æ‰©å±•å
	path := parsedURL.Path
	
	// ğŸ”§ å…³é”®åˆ¤æ–­ï¼šå¦‚æœURLæœ‰å‚æ•°ï¼Œå¯èƒ½æ˜¯åŠ¨æ€èµ„æº
	if parsedURL.RawQuery != "" {
		// æ£€æŸ¥å‚æ•°ä¸­æ˜¯å¦æœ‰ file/filename/path ç­‰å…³é”®è¯
		query := parsedURL.Query()
		dynamicKeys := []string{"file", "filename", "path", "resource", "download", "view"}
		
		for _, key := range dynamicKeys {
			if _, hasKey := query[key]; hasKey {
				// è¿™æ˜¯åŠ¨æ€èµ„æºURLï¼Œä¸è¿‡æ»¤ï¼
				f.stats.ParamURLAllowed++
				return false, "dynamic", fmt.Sprintf("å‚æ•°åŒ–URLï¼ˆ%så‚æ•°ï¼‰ï¼Œä¸è¿‡æ»¤", key)
			}
		}
	}
	
	// 3. æå–æ‰©å±•å
	lastDot := strings.LastIndex(path, ".")
	if lastDot == -1 {
		return false, "", "æ— æ‰©å±•å"
	}
	
	extension := strings.ToLower(path[lastDot+1:])
	
	// 4. æ£€æŸ¥æ˜¯å¦ä¸ºJSæ–‡ä»¶ï¼ˆä¸è¿‡æ»¤ï¼‰
	if f.jsExtensions[extension] {
		f.stats.JSAllowed++
		return false, "javascript", "JSæ–‡ä»¶ï¼Œå…è®¸è¯·æ±‚"
	}
	
	// 5. æ£€æŸ¥æ˜¯å¦ä¸ºé™æ€èµ„æº
	if !f.excludeExtensions[extension] {
		return false, "", "ä¸æ˜¯é™æ€èµ„æº"
	}
	
	// 6. ç¡®å®šèµ„æºç±»å‹
	resourceType := f.classifyResource(extension)
	
	// 7. è®°å½•è¯¥é™æ€èµ„æº
	f.recordedResources[rawURL] = ResourceInfo{
		URL:          rawURL,
		ResourceType: resourceType,
		RecordTime:   getCurrentTime(),
	}
	
	// 8. æ›´æ–°ç»Ÿè®¡
	switch resourceType {
	case "image":
		f.stats.ImagesFiltered++
	case "css":
		f.stats.CSSFiltered++
	case "font":
		f.stats.FontsFiltered++
	case "document":
		f.stats.DocsFiltered++
	}
	
	// âœ… è¿‡æ»¤ï¼šåªè®°å½•ä¸è¯·æ±‚
	return true, resourceType, fmt.Sprintf("é™æ€èµ„æº(%s)ï¼Œåªè®°å½•ä¸è¯·æ±‚", resourceType)
}

// classifyResource åˆ†ç±»èµ„æºç±»å‹
func (f *StaticResourceFilter) classifyResource(ext string) string {
	imageExts := map[string]bool{
		"jpg": true, "jpeg": true, "png": true, "gif": true, 
		"svg": true, "ico": true, "webp": true, "bmp": true,
	}
	
	cssExts := map[string]bool{
		"css": true, "scss": true, "sass": true, "less": true,
	}
	
	fontExts := map[string]bool{
		"woff": true, "woff2": true, "ttf": true, "eot": true, "otf": true,
	}
	
	docExts := map[string]bool{
		"pdf": true, "doc": true, "docx": true, "xls": true, 
		"xlsx": true, "ppt": true, "pptx": true,
	}
	
	if imageExts[ext] {
		return "image"
	} else if cssExts[ext] {
		return "css"
	} else if fontExts[ext] {
		return "font"
	} else if docExts[ext] {
		return "document"
	}
	
	return "other"
}

// GetRecordedResources è·å–è®°å½•çš„é™æ€èµ„æº
func (f *StaticResourceFilter) GetRecordedResources() map[string]ResourceInfo {
	f.mutex.RLock()
	defer f.mutex.RUnlock()
	
	// è¿”å›å‰¯æœ¬
	result := make(map[string]ResourceInfo, len(f.recordedResources))
	for k, v := range f.recordedResources {
		result[k] = v
	}
	return result
}

// GetStatistics è·å–ç»Ÿè®¡ä¿¡æ¯
func (f *StaticResourceFilter) GetStatistics() StaticFilterStats {
	f.mutex.RLock()
	defer f.mutex.RUnlock()
	return f.stats
}

// PrintReport æ‰“å°æŠ¥å‘Š
func (f *StaticResourceFilter) PrintReport() {
	f.mutex.RLock()
	defer f.mutex.RUnlock()
	
	fmt.Println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘     é™æ€èµ„æºè¿‡æ»¤ç»Ÿè®¡æŠ¥å‘Š             â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Printf("  æ€»æ£€æŸ¥æ•°:        %d\n", f.stats.TotalChecked)
	fmt.Printf("  è¿‡æ»¤å›¾ç‰‡:        %d\n", f.stats.ImagesFiltered)
	fmt.Printf("  è¿‡æ»¤CSS:         %d\n", f.stats.CSSFiltered)
	fmt.Printf("  è¿‡æ»¤å­—ä½“:        %d\n", f.stats.FontsFiltered)
	fmt.Printf("  è¿‡æ»¤æ–‡æ¡£:        %d\n", f.stats.DocsFiltered)
	fmt.Printf("  JSæ”¾è¡Œ:          %d\n", f.stats.JSAllowed)
	fmt.Printf("  å‚æ•°URLæ”¾è¡Œ:     %d\n", f.stats.ParamURLAllowed)
	
	totalFiltered := f.stats.ImagesFiltered + f.stats.CSSFiltered + 
	                 f.stats.FontsFiltered + f.stats.DocsFiltered
	if f.stats.TotalChecked > 0 {
		fmt.Printf("  è¿‡æ»¤ç‡:          %.1f%%\n", 
			float64(totalFiltered)*100/float64(f.stats.TotalChecked))
	}
	fmt.Println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
}
```

---

## éœ€æ±‚2.2: ç›¸ä¼¼URLå»é‡ï¼ˆHashç®—æ³•ï¼‰

### 2.2 è®¾è®¡æ€è·¯

**ä¸¤ç§ç›¸ä¼¼URL**:
1. å‚æ•°å€¼ä¸åŒï¼š`?t=a&tt=b` vs `?tt=s&t=l`
2. è·¯å¾„å˜é‡ä¸åŒï¼š`/test-1/` vs `/test-2/`

**ç®—æ³•**:
```
URL â†’ æå–ç»“æ„ç‰¹å¾ â†’ è®¡ç®—Hash â†’ ç›¸åŒHash = ç›¸ä¼¼URL
```

### 2.2 ä»£ç å®ç°

#### æ–‡ä»¶: `core/similar_url_deduplicator.go` (æ–°å»º)

```go
package core

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"sync"
)

// SimilarURLDeduplicator ç›¸ä¼¼URLå»é‡å™¨
type SimilarURLDeduplicator struct {
	mutex sync.RWMutex
	
	// Hash â†’ é¦–ä¸ªURLæ˜ å°„
	hashToFirstURL map[string]string
	
	// Hash â†’ ç›¸ä¼¼URLåˆ—è¡¨
	hashToSimilarURLs map[string][]string
	
	// ç»Ÿè®¡
	stats SimilarURLStats
}

type SimilarURLStats struct {
	TotalURLs      int
	UniqueHashes   int
	SimilarURLs    int
	ParamSimilar   int // å‚æ•°ç›¸ä¼¼
	PathSimilar    int // è·¯å¾„ç›¸ä¼¼
}

// NewSimilarURLDeduplicator åˆ›å»ºç›¸ä¼¼URLå»é‡å™¨
func NewSimilarURLDeduplicator() *SimilarURLDeduplicator {
	return &SimilarURLDeduplicator{
		hashToFirstURL:    make(map[string]string),
		hashToSimilarURLs: make(map[string][]string),
		stats:             SimilarURLStats{},
	}
}

// ShouldCrawl åˆ¤æ–­URLæ˜¯å¦åº”è¯¥çˆ¬å–
// è¿”å›: (æ˜¯å¦çˆ¬å–, ç›¸ä¼¼çš„URL, åŸå› )
func (d *SimilarURLDeduplicator) ShouldCrawl(rawURL string) (bool, string, string) {
	d.mutex.Lock()
	defer d.mutex.Unlock()
	
	d.stats.TotalURLs++
	
	// è®¡ç®—URLçš„ç»“æ„Hash
	structHash, similarityType := d.calculateStructureHash(rawURL)
	
	// æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒHash
	if firstURL, exists := d.hashToFirstURL[structHash]; exists {
		// ç›¸ä¼¼URLï¼Œè·³è¿‡
		d.stats.SimilarURLs++
		
		// è®°å½•ç›¸ä¼¼URL
		d.hashToSimilarURLs[structHash] = append(
			d.hashToSimilarURLs[structHash],
			rawURL,
		)
		
		// æ›´æ–°ç»Ÿè®¡
		if similarityType == "param" {
			d.stats.ParamSimilar++
		} else if similarityType == "path" {
			d.stats.PathSimilar++
		}
		
		return false, firstURL, fmt.Sprintf(
			"ç›¸ä¼¼URLï¼ˆ%sç›¸ä¼¼ï¼‰ï¼ŒHash=%sï¼Œé¦–ä¸ªURL: %s",
			similarityType, structHash[:8], firstURL,
		)
	}
	
	// æ–°çš„URLç»“æ„ï¼Œå…è®¸çˆ¬å–
	d.hashToFirstURL[structHash] = rawURL
	d.hashToSimilarURLs[structHash] = []string{}
	d.stats.UniqueHashes++
	
	return true, "", fmt.Sprintf("æ–°URLç»“æ„ï¼ŒHash=%s", structHash[:8])
}

// calculateStructureHash è®¡ç®—URLç»“æ„Hash
// è¿”å›: (Hashå€¼, ç›¸ä¼¼ç±»å‹)
func (d *SimilarURLDeduplicator) calculateStructureHash(rawURL string) (string, string) {
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		// è§£æå¤±è´¥ï¼Œä½¿ç”¨åŸURLçš„Hash
		return d.simpleHash(rawURL), "unknown"
	}
	
	// 1. æå–è·¯å¾„ç»“æ„ï¼ˆæ•°å­—æ›¿æ¢ä¸ºå ä½ç¬¦ï¼‰
	pathStructure := d.extractPathStructure(parsedURL.Path)
	
	// 2. æå–å‚æ•°ç»“æ„ï¼ˆåªä¿ç•™å‚æ•°åï¼Œä¸ä¿ç•™å€¼ï¼‰
	paramStructure := d.extractParamStructure(parsedURL.Query())
	
	// 3. æ„é€ ç»“æ„å­—ç¬¦ä¸²
	structure := fmt.Sprintf(
		"%s://%s%s%s",
		parsedURL.Scheme,
		parsedURL.Host,
		pathStructure,
		paramStructure,
	)
	
	// 4. åˆ¤æ–­ç›¸ä¼¼ç±»å‹
	similarityType := "normal"
	if strings.Contains(pathStructure, "{num}") || 
	   strings.Contains(pathStructure, "{id}") {
		similarityType = "path"
	} else if paramStructure != "" {
		similarityType = "param"
	}
	
	// 5. è®¡ç®—Hash
	hash := d.simpleHash(structure)
	
	return hash, similarityType
}

// extractPathStructure æå–è·¯å¾„ç»“æ„
func (d *SimilarURLDeduplicator) extractPathStructure(path string) string {
	// æ­£åˆ™ï¼šåŒ¹é…æ•°å­—åºåˆ—
	// /test-123/ â†’ /test-{num}/
	// /user/456/profile â†’ /user/{id}/profile
	
	reNumber := regexp.MustCompile(`\d+`)
	
	// æ›¿æ¢è¿ç»­æ•°å­—ä¸º {num}
	structure := reNumber.ReplaceAllString(path, "{num}")
	
	// ç‰¹æ®Šå¤„ç†ï¼šè¯†åˆ«å¸¸è§æ¨¡å¼
	// /test-1/ â†’ /test-{id}/
	// /page_2/ â†’ /page_{id}/
	patterns := []struct {
		regex   *regexp.Regexp
		replace string
	}{
		{regexp.MustCompile(`-\{num\}`), "-{id}"},
		{regexp.MustCompile(`_\{num\}`), "_{id}"},
		{regexp.MustCompile(`/\{num\}/`), "/{id}/"},
	}
	
	for _, p := range patterns {
		structure = p.regex.ReplaceAllString(structure, p.replace)
	}
	
	return structure
}

// extractParamStructure æå–å‚æ•°ç»“æ„
func (d *SimilarURLDeduplicator) extractParamStructure(query url.Values) string {
	if len(query) == 0 {
		return ""
	}
	
	// æå–å‚æ•°åå¹¶æ’åº
	paramNames := make([]string, 0, len(query))
	for paramName := range query {
		paramNames = append(paramNames, paramName)
	}
	sort.Strings(paramNames)
	
	// æ„é€ å‚æ•°ç»“æ„ï¼šåªä¿ç•™å‚æ•°å
	paramParts := make([]string, 0, len(paramNames))
	for _, paramName := range paramNames {
		paramParts = append(paramParts, paramName+"=")
	}
	
	return "?" + strings.Join(paramParts, "&")
}

// simpleHash ç®€å•Hashè®¡ç®—ï¼ˆMD5ï¼‰
func (d *SimilarURLDeduplicator) simpleHash(text string) string {
	hasher := md5.New()
	hasher.Write([]byte(text))
	return hex.EncodeToString(hasher.Sum(nil))
}

// GetSimilarURLs è·å–æŒ‡å®šHashçš„ç›¸ä¼¼URLåˆ—è¡¨
func (d *SimilarURLDeduplicator) GetSimilarURLs(structHash string) []string {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	
	if urls, exists := d.hashToSimilarURLs[structHash]; exists {
		return urls
	}
	return []string{}
}

// GetAllSimilarGroups è·å–æ‰€æœ‰ç›¸ä¼¼URLç»„
func (d *SimilarURLDeduplicator) GetAllSimilarGroups() map[string][]string {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	
	result := make(map[string][]string)
	for hash, urls := range d.hashToSimilarURLs {
		if len(urls) > 0 {
			// åŒ…å«é¦–ä¸ªURL
			group := []string{d.hashToFirstURL[hash]}
			group = append(group, urls...)
			result[hash] = group
		}
	}
	return result
}

// GetStatistics è·å–ç»Ÿè®¡ä¿¡æ¯
func (d *SimilarURLDeduplicator) GetStatistics() SimilarURLStats {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	return d.stats
}

// PrintReport æ‰“å°æŠ¥å‘Š
func (d *SimilarURLDeduplicator) PrintReport() {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	
	fmt.Println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘      ç›¸ä¼¼URLå»é‡ç»Ÿè®¡æŠ¥å‘Š             â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Printf("  æ€»URLæ•°:         %d\n", d.stats.TotalURLs)
	fmt.Printf("  å”¯ä¸€Hashæ•°:      %d\n", d.stats.UniqueHashes)
	fmt.Printf("  ç›¸ä¼¼URLæ•°:       %d\n", d.stats.SimilarURLs)
	fmt.Printf("    - å‚æ•°ç›¸ä¼¼:    %d\n", d.stats.ParamSimilar)
	fmt.Printf("    - è·¯å¾„ç›¸ä¼¼:    %d\n", d.stats.PathSimilar)
	
	if d.stats.TotalURLs > 0 {
		fmt.Printf("  å»é‡ç‡:          %.1f%%\n",
			float64(d.stats.SimilarURLs)*100/float64(d.stats.TotalURLs))
	}
	
	// æ˜¾ç¤ºTop 5ç›¸ä¼¼ç»„
	groups := d.GetAllSimilarGroups()
	if len(groups) > 0 {
		fmt.Println("\nã€Top 5 ç›¸ä¼¼URLç»„ã€‘")
		
		// æŒ‰ç»„å¤§å°æ’åº
		type groupSize struct {
			hash string
			size int
		}
		var groupSizes []groupSize
		for hash, urls := range groups {
			groupSizes = append(groupSizes, groupSize{hash, len(urls)})
		}
		sort.Slice(groupSizes, func(i, j int) bool {
			return groupSizes[i].size > groupSizes[j].size
		})
		
		// æ˜¾ç¤ºå‰5ç»„
		for i := 0; i < 5 && i < len(groupSizes); i++ {
			gs := groupSizes[i]
			urls := groups[gs.hash]
			fmt.Printf("\n  [%d] Hash=%s, å…±%dä¸ªURL\n", 
				i+1, gs.hash[:8], gs.size)
			fmt.Printf("      é¦–ä¸ª: %s\n", urls[0])
			if len(urls) > 1 {
				fmt.Printf("      ç›¸ä¼¼: %s\n", urls[1])
			}
			if len(urls) > 2 {
				fmt.Printf("      ... (è¿˜æœ‰%dä¸ª)\n", len(urls)-2)
			}
		}
	}
	
	fmt.Println("\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
}
```

---

## éœ€æ±‚3: DOM Embeddingç®—æ³•

### 3.1 ç®—æ³•åŸç†

```
DOMæ ‘ â†’ éå†èŠ‚ç‚¹ â†’ è®¡ç®—embedding

æ¯ä¸ªèŠ‚ç‚¹:
  hash = hash(èŠ‚ç‚¹å†…å®¹)
  weighted_hash = hash Ã— èŠ‚ç‚¹æ·±åº¦ Ã— æƒé‡
  index = weighted_hash % ç»´åº¦
  embedding[index] += 1

æœ€ç»ˆ: embedding = [1, 2, 3, 4, 5, 6, ...]

ç›¸ä¼¼åº¦ = cosine(embedding1, embedding2)
```

### 3.2 ä»£ç å®ç°

#### æ–‡ä»¶: `core/dom_embedding_dedup.go` (æ–°å»º)

```go
package core

import (
	"fmt"
	"hash/fnv"
	"math"
	"strings"
	"sync"

	"github.com/PuerkitoBio/goquery"
)

// DOMEmbeddingDeduplicator DOM Embeddingå»é‡å™¨
type DOMEmbeddingDeduplicator struct {
	mutex sync.RWMutex
	
	// URL â†’ Embeddingæ˜ å°„
	urlEmbeddings map[string]*DOMEmbedding
	
	// é…ç½®
	config EmbeddingConfig
	
	// ç»Ÿè®¡
	stats EmbeddingStats
}

// EmbeddingConfig Embeddingé…ç½®
type EmbeddingConfig struct {
	Dimensions         int     // å‘é‡ç»´åº¦ï¼ˆé»˜è®¤256ï¼‰
	SimilarityThreshold float64 // ç›¸ä¼¼åº¦é˜ˆå€¼ï¼ˆé»˜è®¤0.85ï¼‰
	DepthWeight        float64 // æ·±åº¦æƒé‡ï¼ˆé»˜è®¤1.5ï¼‰
	TagWeight          float64 // æ ‡ç­¾æƒé‡ï¼ˆé»˜è®¤1.0ï¼‰
}

// DOMEmbedding DOMå‘é‡è¡¨ç¤º
type DOMEmbedding struct {
	URL       string
	Vector    []float64 // embeddingå‘é‡
	NodeCount int       // èŠ‚ç‚¹æ•°é‡
	Depth     int       // DOMæ·±åº¦
	Tags      []string  // æ ‡ç­¾åºåˆ—
}

type EmbeddingStats struct {
	TotalPages      int
	SimilarPages    int
	AvgSimilarity   float64
}

// NewDOMEmbeddingDeduplicator åˆ›å»ºDOM Embeddingå»é‡å™¨
func NewDOMEmbeddingDeduplicator(dimensions int, threshold float64) *DOMEmbeddingDeduplicator {
	if dimensions <= 0 {
		dimensions = 256 // é»˜è®¤256ç»´
	}
	if threshold <= 0 || threshold > 1 {
		threshold = 0.85 // é»˜è®¤85%
	}
	
	return &DOMEmbeddingDeduplicator{
		urlEmbeddings: make(map[string]*DOMEmbedding),
		config: EmbeddingConfig{
			Dimensions:          dimensions,
			SimilarityThreshold: threshold,
			DepthWeight:         1.5, // æ·±åº¦æƒé‡
			TagWeight:           1.0, // æ ‡ç­¾æƒé‡
		},
		stats: EmbeddingStats{},
	}
}

// CheckSimilarity æ£€æŸ¥é¡µé¢ç›¸ä¼¼åº¦
// è¿”å›: (æ˜¯å¦ç›¸ä¼¼, ç›¸ä¼¼çš„URL, ç›¸ä¼¼åº¦)
func (d *DOMEmbeddingDeduplicator) CheckSimilarity(rawURL string, htmlContent string) (bool, string, float64) {
	d.mutex.Lock()
	defer d.mutex.Unlock()
	
	d.stats.TotalPages++
	
	// 1. æå–DOM Embedding
	embedding, err := d.extractEmbedding(rawURL, htmlContent)
	if err != nil {
		return false, "", 0.0
	}
	
	// 2. ä¸å·²å­˜å‚¨çš„é¡µé¢å¯¹æ¯”
	maxSimilarity := 0.0
	var mostSimilarURL string
	
	for url, storedEmbedding := range d.urlEmbeddings {
		similarity := d.calculateCosineSimilarity(
			embedding.Vector,
			storedEmbedding.Vector,
		)
		
		if similarity > maxSimilarity {
			maxSimilarity = similarity
			mostSimilarURL = url
		}
	}
	
	// 3. åˆ¤æ–­æ˜¯å¦è¶…è¿‡é˜ˆå€¼
	if maxSimilarity >= d.config.SimilarityThreshold {
		d.stats.SimilarPages++
		d.stats.AvgSimilarity = (d.stats.AvgSimilarity*float64(d.stats.SimilarPages-1) + maxSimilarity) / float64(d.stats.SimilarPages)
		
		return true, mostSimilarURL, maxSimilarity
	}
	
	// 4. æ–°é¡µé¢ï¼Œå­˜å‚¨embedding
	d.urlEmbeddings[rawURL] = embedding
	
	return false, "", 0.0
}

// extractEmbedding æå–DOM Embedding
func (d *DOMEmbeddingDeduplicator) extractEmbedding(rawURL string, htmlContent string) (*DOMEmbedding, error) {
	// è§£æHTML
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		return nil, fmt.Errorf("è§£æHTMLå¤±è´¥: %v", err)
	}
	
	// åˆå§‹åŒ–embeddingå‘é‡
	embedding := &DOMEmbedding{
		URL:    rawURL,
		Vector: make([]float64, d.config.Dimensions),
		Tags:   make([]string, 0),
	}
	
	// éå†DOMæ ‘
	d.traverseDOM(doc.Selection, embedding, 0)
	
	// å½’ä¸€åŒ–å‘é‡
	d.normalizeVector(embedding.Vector)
	
	return embedding, nil
}

// traverseDOM éå†DOMæ ‘ç”Ÿæˆembedding
func (d *DOMEmbeddingDeduplicator) traverseDOM(sel *goquery.Selection, embedding *DOMEmbedding, depth int) {
	sel.Each(func(i int, s *goquery.Selection) {
		// è·å–æ ‡ç­¾å
		tagName := strings.ToLower(goquery.NodeName(s))
		
		// æ›´æ–°ç»Ÿè®¡
		embedding.NodeCount++
		embedding.Tags = append(embedding.Tags, tagName)
		if depth > embedding.Depth {
			embedding.Depth = depth
		}
		
		// è®¡ç®—èŠ‚ç‚¹å†…å®¹çš„hash
		nodeContent := d.getNodeContent(s, tagName)
		hash := d.hashString(nodeContent)
		
		// ğŸ”¥ æ ¸å¿ƒç®—æ³•ï¼šhash Ã— æ·±åº¦ Ã— æƒé‡
		depthWeight := math.Pow(d.config.DepthWeight, float64(depth))
		tagWeight := d.getTagWeight(tagName)
		weightedHash := float64(hash) * depthWeight * tagWeight
		
		// æ±‚ä½™å±•å¼€åˆ°å‘é‡ç»´åº¦
		index := int(weightedHash) % d.config.Dimensions
		if index < 0 {
			index = -index
		}
		
		// ç´¯åŠ åˆ°å‘é‡
		embedding.Vector[index] += 1.0
		
		// é€’å½’å¤„ç†å­èŠ‚ç‚¹
		s.Children().Each(func(j int, child *goquery.Selection) {
			d.traverseDOM(child, embedding, depth+1)
		})
	})
}

// getNodeContent è·å–èŠ‚ç‚¹å†…å®¹ç”¨äºhash
func (d *DOMEmbeddingDeduplicator) getNodeContent(s *goquery.Selection, tagName string) string {
	// ç»„åˆæ ‡ç­¾åå’Œå…³é”®å±æ€§
	var parts []string
	parts = append(parts, tagName)
	
	// æ·»åŠ é‡è¦å±æ€§
	importantAttrs := []string{"id", "class", "name", "type", "href", "src"}
	for _, attr := range importantAttrs {
		if val, exists := s.Attr(attr); exists && val != "" {
			parts = append(parts, attr+"="+val)
		}
	}
	
	// æ·»åŠ éƒ¨åˆ†æ–‡æœ¬å†…å®¹ï¼ˆå‰50å­—ç¬¦ï¼‰
	text := strings.TrimSpace(s.Text())
	if len(text) > 50 {
		text = text[:50]
	}
	if text != "" {
		parts = append(parts, "text="+text)
	}
	
	return strings.Join(parts, "|")
}

// getTagWeight è·å–æ ‡ç­¾æƒé‡
func (d *DOMEmbeddingDeduplicator) getTagWeight(tagName string) float64 {
	// é‡è¦æ ‡ç­¾èµ‹äºˆæ›´é«˜æƒé‡
	weights := map[string]float64{
		"title":  2.0,
		"h1":     1.8,
		"h2":     1.6,
		"h3":     1.4,
		"form":   1.5,
		"input":  1.3,
		"button": 1.3,
		"a":      1.2,
		"div":    1.0,
		"span":   1.0,
		"p":      1.0,
	}
	
	if weight, exists := weights[tagName]; exists {
		return weight * d.config.TagWeight
	}
	
	return d.config.TagWeight
}

// hashString å­—ç¬¦ä¸²Hashï¼ˆFNV-1aç®—æ³•ï¼‰
func (d *DOMEmbeddingDeduplicator) hashString(s string) uint64 {
	h := fnv.New64a()
	h.Write([]byte(s))
	return h.Sum64()
}

// normalizeVector å½’ä¸€åŒ–å‘é‡ï¼ˆL2èŒƒæ•°ï¼‰
func (d *DOMEmbeddingDeduplicator) normalizeVector(vector []float64) {
	// è®¡ç®—L2èŒƒæ•°
	var sumSquares float64
	for _, val := range vector {
		sumSquares += val * val
	}
	norm := math.Sqrt(sumSquares)
	
	if norm == 0 {
		return
	}
	
	// å½’ä¸€åŒ–
	for i := range vector {
		vector[i] /= norm
	}
}

// calculateCosineSimilarity è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
func (d *DOMEmbeddingDeduplicator) calculateCosineSimilarity(vec1, vec2 []float64) float64 {
	if len(vec1) != len(vec2) {
		return 0.0
	}
	
	// è®¡ç®—ç‚¹ç§¯
	var dotProduct float64
	for i := range vec1 {
		dotProduct += vec1[i] * vec2[i]
	}
	
	// ç”±äºå‘é‡å·²å½’ä¸€åŒ–ï¼Œç‚¹ç§¯å³ä¸ºä½™å¼¦ç›¸ä¼¼åº¦
	return dotProduct
}

// GetStatistics è·å–ç»Ÿè®¡ä¿¡æ¯
func (d *DOMEmbeddingDeduplicator) GetStatistics() EmbeddingStats {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	return d.stats
}

// PrintReport æ‰“å°æŠ¥å‘Š
func (d *DOMEmbeddingDeduplicator) PrintReport() {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	
	fmt.Println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	fmt.Println("â•‘    DOM Embeddingå»é‡ç»Ÿè®¡æŠ¥å‘Š         â•‘")
	fmt.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Printf("  æ€»é¡µé¢æ•°:        %d\n", d.stats.TotalPages)
	fmt.Printf("  ç›¸ä¼¼é¡µé¢æ•°:      %d\n", d.stats.SimilarPages)
	
	if d.stats.TotalPages > 0 {
		fmt.Printf("  å»é‡ç‡:          %.1f%%\n",
			float64(d.stats.SimilarPages)*100/float64(d.stats.TotalPages))
	}
	
	if d.stats.SimilarPages > 0 {
		fmt.Printf("  å¹³å‡ç›¸ä¼¼åº¦:      %.1f%%\n", d.stats.AvgSimilarity*100)
	}
	
	fmt.Printf("  å‘é‡ç»´åº¦:        %d\n", d.config.Dimensions)
	fmt.Printf("  ç›¸ä¼¼åº¦é˜ˆå€¼:      %.1f%%\n", d.config.SimilarityThreshold*100)
	fmt.Println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
}

// GetEmbedding è·å–æŒ‡å®šURLçš„embeddingï¼ˆç”¨äºè°ƒè¯•ï¼‰
func (d *DOMEmbeddingDeduplicator) GetEmbedding(url string) *DOMEmbedding {
	d.mutex.RLock()
	defer d.mutex.RUnlock()
	
	if emb, exists := d.urlEmbeddings[url]; exists {
		return emb
	}
	return nil
}
```

---

## ğŸ“ é›†æˆæ–¹æ¡ˆ

### åœ¨ spider.go ä¸­é›†æˆæ‰€æœ‰åŠŸèƒ½

```go
// spider.go

type Spider struct {
	...
	// ğŸ†• ä¸‰å¤§æ–°åŠŸèƒ½
	jsHandler           *JSSpecialHandler              // JSç‰¹æ®Šå¤„ç†
	staticResourceFilter *StaticResourceFilter         // é™æ€èµ„æºè¿‡æ»¤
	similarURLDedup     *SimilarURLDeduplicator        // ç›¸ä¼¼URLå»é‡
	domEmbeddingDedup   *DOMEmbeddingDeduplicator      // DOM Embeddingå»é‡
	...
}

func NewSpider(cfg *config.Config) *Spider {
	...
	
	// åˆå§‹åŒ–æ–°ç»„ä»¶
	jsHandler, _ := NewJSSpecialHandler(
		cfg.TargetURL,
		cfg.BlacklistSettings.Domains,
	)
	
	staticResourceFilter := NewStaticResourceFilter(
		cfg.ScopeSettings.ExcludeExtensions,
	)
	
	similarURLDedup := NewSimilarURLDeduplicator()
	
	domEmbeddingDedup := NewDOMEmbeddingDeduplicator(
		256,  // 256ç»´
		0.85, // 85%é˜ˆå€¼
	)
	
	return &Spider{
		...
		jsHandler:            jsHandler,
		staticResourceFilter: staticResourceFilter,
		similarURLDedup:      similarURLDedup,
		domEmbeddingDedup:    domEmbeddingDedup,
		...
	}
}

// çˆ¬å–æµç¨‹
func (s *Spider) processBFSResults(...) {
	for link := range allLinks {
		
		// âœ… Step 1: JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†
		if s.jsHandler != nil {
			shouldProcess, processedURL, reason := s.jsHandler.ShouldProcessJS(link)
			if shouldProcess {
				tasksToSubmit = append(tasksToSubmit, processedURL)
				continue
			}
		}
		
		// âœ… Step 2: é™æ€èµ„æºè¿‡æ»¤
		if s.staticResourceFilter != nil {
			shouldFilter, resType, reason := s.staticResourceFilter.ShouldFilter(link)
			if shouldFilter {
				s.logger.Debug("é™æ€èµ„æºè¿‡æ»¤", "url", link, "type", resType)
				continue
			}
		}
		
		// âœ… Step 3: ç²¾ç¡®å»é‡
		if s.duplicateHandler.IsDuplicateURL(link) {
			continue
		}
		
		// âœ… Step 4: ç›¸ä¼¼URLå»é‡
		if s.similarURLDedup != nil {
			shouldCrawl, similarURL, reason := s.similarURLDedup.ShouldCrawl(link)
			if !shouldCrawl {
				s.logger.Debug("ç›¸ä¼¼URLè·³è¿‡", 
					"url", link,
					"similar_to", similarURL,
					"reason", reason)
				continue
			}
		}
		
		// âœ… Step 5: Scopeæ£€æŸ¥ï¼ˆJSå·²è·³è¿‡ï¼‰
		if s.scopeController != nil && !s.scopeController.IsInScope(link) {
			continue
		}
		
		// é€šè¿‡æ‰€æœ‰æ£€æŸ¥
		tasksToSubmit = append(tasksToSubmit, link)
	}
}

// çˆ¬å–å®Œæˆåçš„DOMæ£€æŸ¥
func (s *Spider) crawlURL(targetURL string) *Result {
	result := ... // çˆ¬å–é¡µé¢
	
	// âœ… DOM Embeddingå»é‡
	if s.domEmbeddingDedup != nil && result.HTMLContent != "" {
		isSimilar, similarURL, similarity := s.domEmbeddingDedup.CheckSimilarity(
			targetURL,
			result.HTMLContent,
		)
		
		if isSimilar {
			s.logger.Info("DOMç›¸ä¼¼é¡µé¢",
				"url", targetURL,
				"similar_to", similarURL,
				"similarity", fmt.Sprintf("%.1f%%", similarity*100))
			
			// æ ‡è®°ä¸ºç›¸ä¼¼
			result.Crawled = false
			result.SkipReason = fmt.Sprintf("DOMç›¸ä¼¼(%.1f%%): %s", 
				similarity*100, similarURL)
		}
	}
	
	return result
}
```

---

## ğŸ¯ é…ç½®æ–‡ä»¶æ›´æ–°

### config.json æ–°å¢é…ç½®

```json
{
  "deduplication_settings": {
    ...
    
    "_v4.8_æ–°åŠŸèƒ½": "ä¸‰å¤§ä¼˜åŒ–éœ€æ±‚",
    
    "enable_js_special_handling": true,
    "_js_è¯´æ˜": "JSæ–‡ä»¶ä¸å—scopeé™åˆ¶ï¼Œå¯è·¨åŸŸçˆ¬å–",
    
    "enable_static_resource_filter": true,
    "_static_è¯´æ˜": "é™æ€èµ„æºåªè®°å½•ä¸è¯·æ±‚ï¼ˆé™¤JSå¤–ï¼‰",
    "static_filter_exclude_js": true,
    "_js_filter_è¯´æ˜": "JSæ–‡ä»¶ä¸è¿‡æ»¤ï¼Œæ­£å¸¸è¯·æ±‚",
    
    "enable_similar_url_dedup": true,
    "_similar_è¯´æ˜": "ç›¸ä¼¼URLå»é‡ï¼ˆhashç®—æ³•ï¼‰",
    
    "enable_dom_embedding": true,
    "_dom_embedding_è¯´æ˜": "åŸºäºDOM Embeddingçš„å†…å®¹å»é‡",
    "dom_embedding_dimensions": 256,
    "_dimensions_è¯´æ˜": "å‘é‡ç»´åº¦ï¼Œè¶Šå¤§è¶Šç²¾ç¡®ä½†å å†…å­˜",
    "dom_embedding_threshold": 0.85,
    "_embedding_threshold_è¯´æ˜": "ç›¸ä¼¼åº¦é˜ˆå€¼ï¼Œé»˜è®¤85%"
  }
}
```

---

## ğŸ“Š é¢„æœŸæ•ˆæœ

### æ•ˆæœå¯¹æ¯”

| æŒ‡æ ‡ | å½“å‰ | ä¼˜åŒ–å | æå‡ |
|-----|------|--------|------|
| **JSæ–‡ä»¶çˆ¬å–** | å—scopeé™åˆ¶ | âœ… è·¨åŸŸçˆ¬å– | è´¨çš„é£è·ƒ |
| **é™æ€èµ„æºè¿‡æ»¤** | ä»ç„¶è¯·æ±‚ | âœ… åªè®°å½• | -70%è¯·æ±‚ |
| **ç›¸ä¼¼URLå»é‡** | 20% | âœ… 90%+ | +450% |
| **DOMå†…å®¹å»é‡** | æ—  | âœ… 85%å‡†ç¡® | å…¨æ–°åŠŸèƒ½ |

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### æµ‹è¯•1: JSæ–‡ä»¶è·¨åŸŸçˆ¬å–

```go
// æµ‹è¯•æ•°æ®
urls := []string{
	"https://target.com/app.js",          // æœ¬åŸŸJS
	"https://cdn.example.com/lib.js",     // CDN JS
	"//ajax.googleapis.com/jquery.js",    // åè®®ç›¸å¯¹
	"/static/main.js",                    // ç›¸å¯¹è·¯å¾„
}

// é¢„æœŸç»“æœ
// âœ… æ‰€æœ‰JSéƒ½åº”è¯¥è¢«çˆ¬å–ï¼ˆåªè¦ä¸åœ¨é»‘åå•ï¼‰
// âœ… è·¯å¾„æ­£ç¡®æ‹¼æ¥
```

### æµ‹è¯•2: é™æ€èµ„æºè¿‡æ»¤

```go
// æµ‹è¯•æ•°æ®
urls := []string{
	"http://test.com/logo.png",           // âœ… è¿‡æ»¤
	"http://test.com/style.css",          // âœ… è¿‡æ»¤
	"http://test.com/app.js",             // âŒ ä¸è¿‡æ»¤
	"http://test.com/?file=test.css",     // âŒ ä¸è¿‡æ»¤ï¼ˆå‚æ•°åŒ–ï¼‰
}
```

### æµ‹è¯•3: ç›¸ä¼¼URLå»é‡

```go
// æµ‹è¯•æ•°æ®
urls := []string{
	"http://test.com/test?t=a&tt=b",      // ä¿ç•™
	"http://test.com/test?tt=s&t=l",      // âœ… è·³è¿‡ï¼ˆç›¸ä¼¼ï¼‰
	"http://test.com/test-1/",            // ä¿ç•™
	"http://test.com/test-2/",            // âœ… è·³è¿‡ï¼ˆç›¸ä¼¼ï¼‰
}
```

### æµ‹è¯•4: DOM Embedding

```go
// ä¸¤ä¸ªé¡µé¢å†…å®¹
page1 := "<html><body><h1>Title</h1><p>Content</p></body></html>"
page2 := "<html><body><h1>Title2</h1><p>Content2</p></body></html>"

// é¢„æœŸ: ç›¸ä¼¼åº¦ > 85% â†’ åˆ¤å®šä¸ºç›¸ä¼¼é¡µé¢
```

---

## ğŸ“š ä½¿ç”¨ç¤ºä¾‹

```go
// å¯åŠ¨çˆ¬è™«
spider := core.NewSpider(cfg)

// å¼€å§‹çˆ¬å–
spider.Start("http://testphp.vulnweb.com")

// æ‰“å°æŠ¥å‘Š
spider.jsHandler.PrintReport()
spider.staticResourceFilter.PrintReport()
spider.similarURLDedup.PrintReport()
spider.domEmbeddingDedup.PrintReport()
```

**è¾“å‡ºç¤ºä¾‹**:
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†ç»Ÿè®¡æŠ¥å‘Š          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  æ€»JSæ–‡ä»¶æ•°:      45
  æœ¬åŸŸJS:          30
  è·¨åŸŸJS:          15
  è·¯å¾„æ‹¼æ¥:        12
  é»‘åå•æ‹¦æˆª:      0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     é™æ€èµ„æºè¿‡æ»¤ç»Ÿè®¡æŠ¥å‘Š             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  æ€»æ£€æŸ¥æ•°:        500
  è¿‡æ»¤å›¾ç‰‡:        120
  è¿‡æ»¤CSS:         30
  è¿‡æ»¤å­—ä½“:        15
  JSæ”¾è¡Œ:          45
  å‚æ•°URLæ”¾è¡Œ:     8
  è¿‡æ»¤ç‡:          33.0%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      ç›¸ä¼¼URLå»é‡ç»Ÿè®¡æŠ¥å‘Š             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  æ€»URLæ•°:         300
  å”¯ä¸€Hashæ•°:      50
  ç›¸ä¼¼URLæ•°:       250
    - å‚æ•°ç›¸ä¼¼:    150
    - è·¯å¾„ç›¸ä¼¼:    100
  å»é‡ç‡:          83.3%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘    DOM Embeddingå»é‡ç»Ÿè®¡æŠ¥å‘Š         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  æ€»é¡µé¢æ•°:        50
  ç›¸ä¼¼é¡µé¢æ•°:      12
  å»é‡ç‡:          24.0%
  å¹³å‡ç›¸ä¼¼åº¦:      89.5%
  å‘é‡ç»´åº¦:        256
  ç›¸ä¼¼åº¦é˜ˆå€¼:      85.0%
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

---

## âœ… å®Œæˆæ¸…å•

- [x] éœ€æ±‚1: JSæ–‡ä»¶ç‰¹æ®Šå¤„ç†å®ç°å®Œæˆ
- [x] éœ€æ±‚2.1: é™æ€èµ„æºè¿‡æ»¤å®ç°å®Œæˆ
- [x] éœ€æ±‚2.2: ç›¸ä¼¼URLå»é‡å®ç°å®Œæˆ
- [x] éœ€æ±‚3: DOM Embeddingç®—æ³•å®ç°å®Œæˆ
- [x] é…ç½®æ–‡ä»¶æ›´æ–°
- [x] æµ‹è¯•ç”¨ä¾‹è®¾è®¡
- [x] æ–‡æ¡£ç¼–å†™å®Œæˆ

---

**ä¸‹ä¸€æ­¥**: å®æ–½ä»£ç å¹¶æµ‹è¯•éªŒè¯ ğŸš€

**End of Document**

