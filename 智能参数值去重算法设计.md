# 智能参数值去重算法设计

## 🎯 设计目标

**用户需求**: 
- 参数字段相同但值不同的URL，如果参数值特征相似（如长度相同），超过N个就跳过
- 避免大量无意义的URL重复爬取

**示例**:
```
http://test.com?id=1234567890  (10位数字) ✅ 爬取
http://test.com?id=9876543210  (10位数字) ✅ 爬取
http://test.com?id=5555555555  (10位数字) ✅ 爬取 (第3个)
http://test.com?id=1111111111  (10位数字) ❌ 跳过 (已有3个相似的)
http://test.com?id=2222222222  (10位数字) ❌ 跳过
```

---

## 📐 算法设计

### 核心概念

#### 1. URL模式 (Pattern)

**定义**: URL的路径 + 参数名（不包含参数值）

**示例**:
```
http://test.com?id=1        → 模式: http://test.com?id
http://test.com?id=2        → 模式: http://test.com?id (相同)
http://test.com?id=admin    → 模式: http://test.com?id (相同)

http://test.com?id=1&page=1 → 模式: http://test.com?id&page
http://test.com?id=2&page=2 → 模式: http://test.com?id&page (相同)
```

#### 2. 参数值特征 (Value Feature)

**定义**: 参数值的分类标签，基于长度和类型

**分类维度**:

##### A. 数字型（按长度）
- `num_1_5`: 1-5位数字 (例: 1, 123, 12345)
- `num_6_10`: 6-10位数字 (例: 123456, 1234567890)
- `num_11_20`: 11-20位数字 (例: 手机号13800138000)
- `num_20+`: 20位以上数字 (例: 时间戳)

##### B. 字母型（按长度）
- `alpha_1_5`: 1-5位字母 (例: admin, test, user)
- `alpha_6_10`: 6-10位字母 (例: username, password)
- `alpha_11+`: 11位以上字母 (例: administrator)

##### C. 混合型
- `alphanum`: 字母数字混合 (例: user123, abc456)

##### D. 特殊格式
- `uuid`: UUID格式 (例: 550e8400-e29b-41d4-a716-446655440000)
- `md5`: MD5哈希 (例: 5d41402abc4b2a76b9719d911017c592)
- `sha1`: SHA1哈希 (40位hex)
- `sha256`: SHA256哈希 (64位hex)
- `base64`: Base64编码
- `hex`: 十六进制字符串

##### E. 安全测试
- `path_trav`: 路径穿越 (例: ../, ../../etc/passwd)
- `special`: 特殊字符 (例: <script>, ' OR '1'='1)

##### F. 其他
- `empty`: 空值
- `other`: 其他类型

#### 3. 特征组计数

**数据结构**:
```go
PatternInfo {
    Pattern: "http://test.com?id"
    ValueGroups: {
        "num_6_10": 3,      // 已爬取3个6-10位数字
        "alpha_1_5": 2,     // 已爬取2个1-5位字母
        "path_trav": 1,     // 已爬取1个路径穿越
    }
    AllValues: ["1234567890", "9876543210", "5555555555", "admin", "test", "../"]
}
```

---

## 🔄 算法流程

### 主流程

```
输入: URL = http://test.com?id=1234567890

第1步: 提取URL模式
  ↓
Pattern = "http://test.com?id"
ParamValue = "1234567890"

第2步: 检查是否为新模式
  ↓
如果是新模式 → 初始化 → 允许爬取 → 结束

第3步: 对参数值分类
  ↓
ValueClass = ClassifyParamValue("1234567890")
           = "num_6_10" (6-10位数字)

第4步: 检查该特征组的计数
  ↓
CurrentCount = PatternInfo.ValueGroups["num_6_10"]
             = 2 (已爬取2个)

第5步: 判断是否达到限制
  ↓
如果 CurrentCount >= MaxPerGroup(3):
    ✗ 跳过该URL
否则:
    ✓ 允许爬取
    ✓ 更新计数: ValueGroups["num_6_10"]++
```

---

## 📊 实际案例演示

### 案例1: XSS Quiz站点

**发现的URL序列**:
```
1. https://xss-quiz.int21h.jp/?id=1
2. https://xss-quiz.int21h.jp/?id=2
3. https://xss-quiz.int21h.jp/?id=123
4. https://xss-quiz.int21h.jp/?id=12345
5. https://xss-quiz.int21h.jp/?id=admin
6. https://xss-quiz.int21h.jp/?id=test
7. https://xss-quiz.int21h.jp/?id=user
8. https://xss-quiz.int21h.jp/?id=debug
9. https://xss-quiz.int21h.jp/?id=1234567890
10. https://xss-quiz.int21h.jp/?id=9876543210
11. https://xss-quiz.int21h.jp/?id=5555555555
12. https://xss-quiz.int21h.jp/?id=..%2F
```

**智能去重处理** (maxPerGroup=3):
```
URL模式: https://xss-quiz.int21h.jp/?id

序号1: ?id=1
  特征: num_1_5 (1-5位数字)
  计数: 1/3
  结果: ✅ 爬取

序号2: ?id=2
  特征: num_1_5
  计数: 2/3
  结果: ✅ 爬取

序号3: ?id=123
  特征: num_1_5
  计数: 3/3
  结果: ✅ 爬取

序号4: ?id=12345
  特征: num_1_5
  计数: 已达限制 (3/3)
  结果: ❌ 跳过！(相同特征已有3个)

序号5: ?id=admin
  特征: alpha_1_5 (1-5位字母)
  计数: 1/3
  结果: ✅ 爬取 (新特征组)

序号6: ?id=test
  特征: alpha_1_5
  计数: 2/3
  结果: ✅ 爬取

序号7: ?id=user
  特征: alpha_1_5
  计数: 3/3
  结果: ✅ 爬取

序号8: ?id=debug
  特征: alpha_1_5
  计数: 已达限制 (3/3)
  结果: ❌ 跳过！

序号9: ?id=1234567890
  特征: num_6_10 (6-10位数字)
  计数: 1/3
  结果: ✅ 爬取 (新特征组)

序号10: ?id=9876543210
  特征: num_6_10
  计数: 2/3
  结果: ✅ 爬取

序号11: ?id=5555555555
  特征: num_6_10
  计数: 3/3
  结果: ✅ 爬取

序号12: ?id=..%2F
  特征: path_trav (路径穿越)
  计数: 1/3
  结果: ✅ 爬取 (新特征组)
```

**统计**:
```
发现URL: 12个
实际爬取: 9个 (75%)
智能跳过: 3个 (25%)

特征组分布:
  - num_1_5: 3个 (达到限制)
  - alpha_1_5: 3个 (达到限制)
  - num_6_10: 3个 (达到限制)
  - path_trav: 1个

节省请求: 25%
```

---

### 案例2: 大型电商网站

**商品ID URL**:
```
http://shop.com/product?id=10001
http://shop.com/product?id=10002
http://shop.com/product?id=10003
... (1000个类似的商品ID)
```

**智能去重效果** (maxPerGroup=3):
```
URL模式: http://shop.com/product?id

1. ?id=10001  → num_1_5 → 爬取 ✅
2. ?id=10002  → num_1_5 → 爬取 ✅
3. ?id=10003  → num_1_5 → 爬取 ✅
4. ?id=10004  → num_1_5 → 跳过 ❌
...
1000. ?id=11000 → num_1_5 → 跳过 ❌

结果: 1000个URL → 实际爬取3个
节省: 99.7%
```

---

## ⚙️ 配置参数

### 新增配置项

```json
{
  "deduplication_settings": {
    "similarity_threshold": 0.85,
    "enable_dom_deduplication": true,
    "enable_url_pattern_recognition": true,
    
    "_new_feature": "智能参数值去重",
    "enable_smart_param_dedup": true,
    "_smart_dedup_desc": "启用智能参数值去重，避免相似参数值的重复爬取",
    
    "max_param_value_variants_per_group": 3,
    "_max_variants_desc": "每个参数值特征组最多爬取多少个URL",
    "_max_variants_example": "对于10位数字的id参数，最多爬取3个不同的值"
  }
}
```

### 配置说明

| 参数 | 默认值 | 说明 | 示例效果 |
|------|--------|------|---------|
| `enable_smart_param_dedup` | `true` | 是否启用智能去重 | true=启用, false=禁用 |
| `max_param_value_variants_per_group` | `3` | 每组最多爬取数量 | 3=每种特征最多3个 |

**调优建议**:
- `1`: 极度保守（可能漏掉有价值的URL）
- `3`: 推荐默认（平衡覆盖和效率）
- `5`: 宽松模式（更全面但稍慢）
- `10+`: 几乎等于禁用（不推荐）

---

## 📊 效果预测

### 场景1: 参数爆破生成的URL

**优化前**:
```
原始: http://test.com
参数爆破生成:
  ?id=1, ?id=2, ?id=admin, ?id=test, ?id=debug, ?id=123
  ?page=1, ?page=2, ...
  共37个变体 → 全部爬取
```

**优化后**:
```
参数爆破生成:
  ?id=1 (num_1_5) → 爬取 ✅
  
智能去重:
  ?id=2 (num_1_5) → 跳过 ❌ (已有num_1_5特征)
  ?id=admin (alpha_1_5) → 爬取 ✅ (新特征)
  ?id=test (alpha_1_5) → 跳过 ❌
  
共7个参数名 × 1个特征代表 = 7个URL
```

**结果**: 37个 → 7个 (-81%)

---

### 场景2: 自然发现的URL（从您的日志）

**发现序列**:
```
第1层: https://xss-quiz.int21h.jp/
  → 发现链接，爬取

第2层: 爬取后发现
  ?id=1
  ?page=1
  ?search=test
  → 都爬取（新模式）

第3层: 参数爆破+自然发现
  ?id=1 已爬取
  ?id=2        → num_1_5, 2/3 → 爬取
  ?id=admin    → alpha_1_5, 1/3 → 爬取
  ?id=test     → alpha_1_5, 2/3 → 爬取
  ?id=debug    → alpha_1_5, 3/3 → 爬取
  ?id=user     → alpha_1_5, 4/3 → 跳过 ❌
  ?id=123      → num_1_5, 3/3 → 爬取
  ?id=12345    → num_1_5, 4/3 → 跳过 ❌
  ?id=1234567890 → num_6_10, 1/3 → 爬取
  ...
```

**统计**:
- 发现: 50个相似URL
- 爬取: 15个 (每种特征3个)
- 跳过: 35个
- **节省: 70%**

---

## 🎨 特征分类详解

### 数字型特征

```go
func classifyNumeric(value string) string {
    length := len(value)
    
    if length <= 5 {
        return "num_1_5"      // 小数字: 1, 2, 123, 12345
    } else if length <= 10 {
        return "num_6_10"     // 中数字: 123456, 1234567890
    } else if length <= 20 {
        return "num_11_20"    // 大数字: 手机号, 订单号
    } else {
        return "num_20+"      // 超大数字: 时间戳
    }
}
```

**示例**:
```
值: "1"          → num_1_5
值: "123"        → num_1_5   (相同特征)
值: "12345"      → num_1_5   (相同特征)
值: "123456"     → num_6_10  (不同特征)
值: "1234567890" → num_6_10  (相同特征)
```

### 字母型特征

```go
func classifyAlpha(value string) string {
    length := len(value)
    
    if length <= 5 {
        return "alpha_1_5"    // 短单词: admin, test, user
    } else if length <= 10 {
        return "alpha_6_10"   // 中等单词: username, password
    } else {
        return "alpha_11+"    // 长单词: administrator
    }
}
```

**示例**:
```
值: "admin"         → alpha_1_5
值: "test"          → alpha_1_5  (相同特征)
值: "user"          → alpha_1_5  (相同特征)
值: "username"      → alpha_6_10 (不同特征)
值: "administrator" → alpha_11+  (不同特征)
```

### 特殊格式识别

```go
// UUID格式
"550e8400-e29b-41d4-a716-446655440000" → uuid

// MD5哈希
"5d41402abc4b2a76b9719d911017c592" → md5

// 路径穿越
"../"                → path_trav
"../../etc/passwd"   → path_trav (相同特征)
"../config.php"      → path_trav (相同特征)
```

---

## 🎯 判断逻辑示例

### 伪代码

```python
class SmartParamDedup:
    def __init__(self, max_per_group=3):
        self.patterns = {}  # URL模式 -> PatternInfo
        self.max_per_group = max_per_group
    
    def should_crawl(self, url):
        # 1. 提取模式和参数值
        pattern = extract_pattern(url)  # "http://test.com?id"
        param_value = extract_value(url)  # "1234567890"
        
        # 2. 新模式，允许爬取
        if pattern not in self.patterns:
            self.patterns[pattern] = {
                'value_groups': {},
                'all_values': []
            }
            self.patterns[pattern]['all_values'].append(param_value)
            feature = classify_value(param_value)
            self.patterns[pattern]['value_groups'][feature] = 1
            return True, f"新模式，允许爬取"
        
        # 3. 对参数值分类
        feature = classify_value(param_value)  # "num_6_10"
        
        # 4. 检查计数
        count = self.patterns[pattern]['value_groups'].get(feature, 0)
        
        if count >= self.max_per_group:
            return False, f"特征 {feature} 已达限制 {count}/{self.max_per_group}"
        
        # 5. 允许爬取，更新计数
        self.patterns[pattern]['value_groups'][feature] = count + 1
        self.patterns[pattern]['all_values'].append(param_value)
        
        return True, f"特征 {feature} 计数 {count+1}/{self.max_per_group}"
```

---

## 💻 完整实现代码

我已创建文件: `core/smart_param_dedup.go`

**核心功能**:
1. ✅ `NewSmartParamDeduplicator()` - 创建去重器
2. ✅ `ShouldCrawl(url)` - 判断是否应该爬取
3. ✅ `classifyParamValue()` - 参数值分类
4. ✅ `extractURLPattern()` - URL模式提取
5. ✅ `GetStatistics()` - 获取统计信息
6. ✅ `PrintStatistics()` - 打印去重效果

---

## 🔧 集成方案

### 需要修改的文件

#### 1. 修改 `config/config.go`

添加新的配置项：

```go
type DeduplicationSettings struct {
    SimilarityThreshold         float64
    EnableDOMDeduplication      bool
    EnableURLPatternRecognition bool
    
    // 新增：智能参数值去重
    EnableSmartParamDedup            bool   // 是否启用
    MaxParamValueVariantsPerGroup    int    // 每组最多爬取数量
}
```

默认配置：

```go
DeduplicationSettings: DeduplicationSettings{
    SimilarityThreshold:              0.85,
    EnableDOMDeduplication:           true,
    EnableURLPatternRecognition:      true,
    EnableSmartParamDedup:            true,  // 默认启用
    MaxParamValueVariantsPerGroup:    3,    // 默认每组3个
},
```

#### 2. 修改 `core/spider.go`

在Spider结构体中添加智能去重器：

```go
type Spider struct {
    config           *config.Config
    duplicateHandler *DuplicateHandler
    smartParamDedup  *SmartParamDeduplicator  // 新增
    // ...
}

func NewSpider(cfg *config.Config) *Spider {
    return &Spider{
        config:           cfg,
        duplicateHandler: NewDuplicateHandler(0.9),
        smartParamDedup:  NewSmartParamDeduplicator(
            cfg.DeduplicationSettings.MaxParamValueVariantsPerGroup,
            cfg.DeduplicationSettings.EnableSmartParamDedup,
        ),
        // ...
    }
}
```

#### 3. 修改爬取逻辑

在添加URL到队列前进行智能去重：

```go
func (s *Spider) shouldCrawlURL(url string) bool {
    // 1. 基础URL去重
    if s.duplicateHandler.IsDuplicateURL(url) {
        return false
    }
    
    // 2. 智能参数值去重
    if s.config.DeduplicationSettings.EnableSmartParamDedup {
        shouldCrawl, reason := s.smartParamDedup.ShouldCrawl(url)
        if !shouldCrawl {
            fmt.Printf("[智能去重] 跳过URL: %s\n  原因: %s\n", url, reason)
            return false
        }
    }
    
    return true
}
```

---

## 📈 预期效果

### 效果对比

| 场景 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| **参数爆破** | 37个变体 | 7-10个 | -70-80% |
| **商品列表** | 1000个商品ID | 3个代表 | -99.7% |
| **用户列表** | 500个用户ID | 3个代表 | -99.4% |
| **哈希URL** | 100个MD5 | 3个MD5 | -97% |
| **综合场景** | 大量重复 | 精简高效 | -80-95% |

### 日志输出示例

**优化后的日志**:
```
[智能去重] URL模式: https://xss-quiz.int21h.jp/?id
[智能去重] 参数值: 1, 特征: num_1_5, 计数: 1/3 → 允许爬取

[智能去重] URL模式: https://xss-quiz.int21h.jp/?id
[智能去重] 参数值: 2, 特征: num_1_5, 计数: 2/3 → 允许爬取

[智能去重] URL模式: https://xss-quiz.int21h.jp/?id
[智能去重] 参数值: 123, 特征: num_1_5, 计数: 3/3 → 允许爬取

[智能去重] 跳过URL: https://xss-quiz.int21h.jp/?id=12345
  原因: 特征组 'num_1_5' 已达限制 (3/3)

[智能去重] URL模式: https://xss-quiz.int21h.jp/?id
[智能去重] 参数值: admin, 特征: alpha_1_5, 计数: 1/3 → 允许爬取

...

============================================================
           智能参数去重统计
============================================================
状态:               true
每组最大数量:       3
URL模式总数:        5
------------------------------------------------------------

模式 1: https://xss-quiz.int21h.jp/?id
  发现值总数: 25
  实际爬取:   9
  智能跳过:   16
  特征组分布:
    - num_1_5: 3个
    - alpha_1_5: 3个
    - num_6_10: 3个
============================================================
```

---

## ✅ 总结

### 算法优势

✅ **智能识别**: 自动识别参数值类型和长度  
✅ **精准去重**: 基于特征分组，不是简单的值比较  
✅ **覆盖全面**: 保留每种特征的代表性URL  
✅ **效率提升**: 减少70-99%的无意义爬取  
✅ **可配置**: 灵活调整每组最大数量  

### 核心机制

**URL模式**: `路径 + 参数名`（忽略参数值）  
**参数值特征**: `长度分类 + 类型分类`  
**限制规则**: 每个模式的每种特征最多爬取N个  

### 下一步

我已经创建了完整的实现代码 `core/smart_param_dedup.go`。

需要我继续集成到主程序中并重新编译吗？
